BEGIN;

CREATE TABLE IF NOT EXISTS public."__EFMigrationsHistory"
(
    migration_id character varying(150) COLLATE pg_catalog."default" NOT NULL,
    product_version character varying(32) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk___ef_migrations_history PRIMARY KEY (migration_id)
);

CREATE TABLE IF NOT EXISTS public.inbox_state
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    message_id uuid NOT NULL,
    consumer_id uuid NOT NULL,
    lock_id uuid NOT NULL,
    row_version bytea,
    received timestamp with time zone NOT NULL,
    receive_count integer NOT NULL,
    expiration_time timestamp with time zone,
    consumed timestamp with time zone,
    delivered timestamp with time zone,
    last_sequence_number bigint,
    CONSTRAINT pk_inbox_state PRIMARY KEY (id),
    CONSTRAINT ak_inbox_state_message_id_consumer_id UNIQUE (message_id, consumer_id)
);

CREATE TABLE IF NOT EXISTS public.outbox_message
(
    sequence_number bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    enqueue_time timestamp with time zone,
    sent_time timestamp with time zone NOT NULL,
    headers text COLLATE pg_catalog."default",
    properties text COLLATE pg_catalog."default",
    inbox_message_id uuid,
    inbox_consumer_id uuid,
    outbox_id uuid,
    message_id uuid NOT NULL,
    content_type character varying(256) COLLATE pg_catalog."default" NOT NULL,
    message_type text COLLATE pg_catalog."default" NOT NULL,
    body text COLLATE pg_catalog."default" NOT NULL,
    conversation_id uuid,
    correlation_id uuid,
    initiator_id uuid,
    request_id uuid,
    source_address character varying(256) COLLATE pg_catalog."default",
    destination_address character varying(256) COLLATE pg_catalog."default",
    response_address character varying(256) COLLATE pg_catalog."default",
    fault_address character varying(256) COLLATE pg_catalog."default",
    expiration_time timestamp with time zone,
    CONSTRAINT pk_outbox_message PRIMARY KEY (sequence_number)
);

CREATE TABLE IF NOT EXISTS public.outbox_state
(
    outbox_id uuid NOT NULL,
    lock_id uuid NOT NULL,
    row_version bytea,
    created timestamp with time zone NOT NULL,
    delivered timestamp with time zone,
    last_sequence_number bigint,
    CONSTRAINT pk_outbox_state PRIMARY KEY (outbox_id)
);

CREATE TABLE IF NOT EXISTS ticker."CronTickerOccurrences"
(
    id uuid NOT NULL,
    status integer NOT NULL,
    lock_holder text COLLATE pg_catalog."default",
    execution_time timestamp with time zone NOT NULL,
    cron_ticker_id uuid NOT NULL,
    locked_at timestamp with time zone,
    executed_at timestamp with time zone,
    exception text COLLATE pg_catalog."default",
    elapsed_time bigint NOT NULL,
    retry_count integer NOT NULL,
    CONSTRAINT pk_cron_ticker_occurrences PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ticker."CronTickers"
(
    id uuid NOT NULL,
    expression text COLLATE pg_catalog."default",
    request bytea,
    retries integer NOT NULL,
    retry_intervals integer[],
    function text COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    init_identifier text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    CONSTRAINT pk_cron_tickers PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ticker."TimeTickers"
(
    id uuid NOT NULL,
    status integer NOT NULL,
    lock_holder text COLLATE pg_catalog."default",
    request bytea,
    execution_time timestamp with time zone NOT NULL,
    locked_at timestamp with time zone,
    executed_at timestamp with time zone,
    exception text COLLATE pg_catalog."default",
    elapsed_time bigint NOT NULL,
    retries integer NOT NULL,
    retry_count integer NOT NULL,
    retry_intervals integer[],
    batch_parent uuid,
    batch_run_condition integer,
    function text COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    init_identifier text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    CONSTRAINT pk_time_tickers PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS public.outbox_message
    ADD CONSTRAINT fk_outbox_message_inbox_state_inbox_message_id_inbox_consumer_ FOREIGN KEY (inbox_message_id, inbox_consumer_id)
    REFERENCES public.inbox_state (message_id, consumer_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.outbox_message
    ADD CONSTRAINT fk_outbox_message_outbox_state_outbox_id FOREIGN KEY (outbox_id)
    REFERENCES public.outbox_state (outbox_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS ticker."CronTickerOccurrences"
    ADD CONSTRAINT fk_cron_ticker_occurrences_cron_tickers_cron_ticker_id FOREIGN KEY (cron_ticker_id)
    REFERENCES ticker."CronTickers" (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_CronTickerOccurrence_CronTickerId"
    ON ticker."CronTickerOccurrences"(cron_ticker_id);


ALTER TABLE IF EXISTS ticker."TimeTickers"
    ADD CONSTRAINT fk_time_tickers_time_tickers_batch_parent FOREIGN KEY (batch_parent)
    REFERENCES ticker."TimeTickers" (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS ix_time_tickers_batch_parent
    ON ticker."TimeTickers"(batch_parent);

END;

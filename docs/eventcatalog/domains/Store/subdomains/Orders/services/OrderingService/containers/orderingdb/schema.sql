BEGIN;

CREATE TABLE IF NOT EXISTS public."__EFMigrationsHistory"
(
    migration_id character varying(150) COLLATE pg_catalog."default" NOT NULL,
    product_version character varying(32) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk___ef_migrations_history PRIMARY KEY (migration_id)
);

CREATE TABLE IF NOT EXISTS public.buyers
(
    id uuid NOT NULL DEFAULT uuidv7(),
    name character varying(20) COLLATE pg_catalog."default" NOT NULL,
    address_street character varying(50) COLLATE pg_catalog."default",
    address_city character varying(50) COLLATE pg_catalog."default",
    address_province character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT pk_buyers PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.inbox_state
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    message_id uuid NOT NULL,
    consumer_id uuid NOT NULL,
    lock_id uuid NOT NULL,
    row_version bytea,
    received timestamp with time zone NOT NULL,
    receive_count integer NOT NULL,
    expiration_time timestamp with time zone,
    consumed timestamp with time zone,
    delivered timestamp with time zone,
    last_sequence_number bigint,
    CONSTRAINT pk_inbox_state PRIMARY KEY (id),
    CONSTRAINT ak_inbox_state_message_id_consumer_id UNIQUE (message_id, consumer_id)
);

CREATE TABLE IF NOT EXISTS public.mt_doc_deadletterevent
(
    id uuid NOT NULL,
    data jsonb NOT NULL,
    mt_last_modified timestamp with time zone DEFAULT transaction_timestamp(),
    mt_version uuid NOT NULL DEFAULT (md5(((random())::text || (clock_timestamp())::text)))::uuid,
    mt_dotnet_type character varying COLLATE pg_catalog."default",
    CONSTRAINT pkey_mt_doc_deadletterevent_id PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.mt_doc_ordersummaryview
(
    id uuid NOT NULL,
    data jsonb NOT NULL,
    mt_last_modified timestamp with time zone DEFAULT transaction_timestamp(),
    mt_dotnet_type character varying COLLATE pg_catalog."default",
    mt_version integer NOT NULL DEFAULT 0,
    CONSTRAINT pkey_mt_doc_ordersummaryview_id PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.mt_event_progression
(
    name character varying COLLATE pg_catalog."default" NOT NULL,
    last_seq_id bigint,
    last_updated timestamp with time zone DEFAULT transaction_timestamp(),
    CONSTRAINT pk_mt_event_progression PRIMARY KEY (name)
);

CREATE TABLE IF NOT EXISTS public.mt_events
(
    seq_id bigint NOT NULL,
    id uuid NOT NULL,
    stream_id uuid,
    version bigint NOT NULL,
    data jsonb NOT NULL,
    type character varying(500) COLLATE pg_catalog."default" NOT NULL,
    "timestamp" timestamp with time zone NOT NULL DEFAULT '2025-09-28 17:03:19.743016+00'::timestamp with time zone,
    tenant_id character varying COLLATE pg_catalog."default" DEFAULT '*DEFAULT*'::character varying,
    mt_dotnet_type character varying COLLATE pg_catalog."default",
    correlation_id character varying COLLATE pg_catalog."default",
    causation_id character varying COLLATE pg_catalog."default",
    headers jsonb,
    is_archived boolean NOT NULL DEFAULT false,
    CONSTRAINT pkey_mt_events_seq_id_is_archived PRIMARY KEY (seq_id, is_archived)
);

CREATE TABLE IF NOT EXISTS public.mt_streams
(
    id uuid NOT NULL,
    type character varying COLLATE pg_catalog."default",
    version bigint,
    "timestamp" timestamp with time zone NOT NULL DEFAULT now(),
    snapshot jsonb,
    snapshot_version integer,
    created timestamp with time zone NOT NULL DEFAULT now(),
    tenant_id character varying COLLATE pg_catalog."default" DEFAULT '*DEFAULT*'::character varying,
    is_archived boolean NOT NULL DEFAULT false,
    CONSTRAINT pkey_mt_streams_id_is_archived PRIMARY KEY (id, is_archived)
);

CREATE TABLE IF NOT EXISTS public.order_items
(
    id uuid NOT NULL DEFAULT uuidv7(),
    quantity integer NOT NULL,
    price numeric NOT NULL,
    book_id uuid NOT NULL,
    order_id uuid NOT NULL,
    CONSTRAINT pk_order_items PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.orders
(
    id uuid NOT NULL DEFAULT uuidv7(),
    status smallint NOT NULL,
    note character varying(500) COLLATE pg_catalog."default",
    buyer_id uuid NOT NULL,
    is_deleted boolean NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'UTC'::text),
    last_modified_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'UTC'::text),
    CONSTRAINT pk_orders PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.outbox_message
(
    sequence_number bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    enqueue_time timestamp with time zone,
    sent_time timestamp with time zone NOT NULL,
    headers text COLLATE pg_catalog."default",
    properties text COLLATE pg_catalog."default",
    inbox_message_id uuid,
    inbox_consumer_id uuid,
    outbox_id uuid,
    message_id uuid NOT NULL,
    content_type character varying(256) COLLATE pg_catalog."default" NOT NULL,
    message_type text COLLATE pg_catalog."default" NOT NULL,
    body text COLLATE pg_catalog."default" NOT NULL,
    conversation_id uuid,
    correlation_id uuid,
    initiator_id uuid,
    request_id uuid,
    source_address character varying(256) COLLATE pg_catalog."default",
    destination_address character varying(256) COLLATE pg_catalog."default",
    response_address character varying(256) COLLATE pg_catalog."default",
    fault_address character varying(256) COLLATE pg_catalog."default",
    expiration_time timestamp with time zone,
    CONSTRAINT pk_outbox_message PRIMARY KEY (sequence_number)
);

CREATE TABLE IF NOT EXISTS public.outbox_state
(
    outbox_id uuid NOT NULL,
    lock_id uuid NOT NULL,
    row_version bytea,
    created timestamp with time zone NOT NULL,
    delivered timestamp with time zone,
    last_sequence_number bigint,
    CONSTRAINT pk_outbox_state PRIMARY KEY (outbox_id)
);

ALTER TABLE IF EXISTS public.mt_events
    ADD CONSTRAINT fkey_mt_events_stream_id_is_archived FOREIGN KEY (stream_id, is_archived)
    REFERENCES public.mt_streams (id, is_archived) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.order_items
    ADD CONSTRAINT fk_order_items_orders_order_id FOREIGN KEY (order_id)
    REFERENCES public.orders (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS ix_order_items_order_id
    ON public.order_items(order_id);


ALTER TABLE IF EXISTS public.orders
    ADD CONSTRAINT fk_orders_buyers_buyer_id FOREIGN KEY (buyer_id)
    REFERENCES public.buyers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS ix_orders_buyer_id
    ON public.orders(buyer_id);


ALTER TABLE IF EXISTS public.outbox_message
    ADD CONSTRAINT fk_outbox_message_inbox_state_inbox_message_id_inbox_consumer_ FOREIGN KEY (inbox_message_id, inbox_consumer_id)
    REFERENCES public.inbox_state (message_id, consumer_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.outbox_message
    ADD CONSTRAINT fk_outbox_message_outbox_state_outbox_id FOREIGN KEY (outbox_id)
    REFERENCES public.outbox_state (outbox_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;

END;

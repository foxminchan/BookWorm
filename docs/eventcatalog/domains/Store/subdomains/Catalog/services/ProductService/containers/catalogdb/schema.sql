BEGIN;

CREATE TABLE IF NOT EXISTS public."__EFMigrationsHistory"
(
    migration_id character varying(150) COLLATE pg_catalog."default" NOT NULL,
    product_version character varying(32) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk___ef_migrations_history PRIMARY KEY (migration_id)
);

CREATE TABLE IF NOT EXISTS public.authors
(
    id uuid NOT NULL DEFAULT uuidv7(),
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_authors PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.book_authors
(
    id uuid NOT NULL DEFAULT uuidv7(),
    author_id uuid NOT NULL,
    book_id uuid NOT NULL,
    CONSTRAINT pk_book_authors PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.books
(
    id uuid NOT NULL DEFAULT uuidv7(),
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    description character varying(1000) COLLATE pg_catalog."default" NOT NULL,
    image character varying(255) COLLATE pg_catalog."default",
    price_original_price numeric(18, 2),
    price_discount_price numeric(18, 2),
    status smallint NOT NULL,
    average_rating double precision NOT NULL DEFAULT 0.0,
    total_reviews integer NOT NULL,
    category_id uuid,
    publisher_id uuid,
    is_deleted boolean NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'UTC'::text),
    last_modified_at timestamp with time zone DEFAULT (now() AT TIME ZONE 'UTC'::text),
    CONSTRAINT pk_books PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.categories
(
    id uuid NOT NULL DEFAULT uuidv7(),
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_categories PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.inbox_state
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    message_id uuid NOT NULL,
    consumer_id uuid NOT NULL,
    lock_id uuid NOT NULL,
    row_version bytea,
    received timestamp with time zone NOT NULL,
    receive_count integer NOT NULL,
    expiration_time timestamp with time zone,
    consumed timestamp with time zone,
    delivered timestamp with time zone,
    last_sequence_number bigint,
    CONSTRAINT pk_inbox_state PRIMARY KEY (id),
    CONSTRAINT ak_inbox_state_message_id_consumer_id UNIQUE (message_id, consumer_id)
);

CREATE TABLE IF NOT EXISTS public.outbox_message
(
    sequence_number bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    enqueue_time timestamp with time zone,
    sent_time timestamp with time zone NOT NULL,
    headers text COLLATE pg_catalog."default",
    properties text COLLATE pg_catalog."default",
    inbox_message_id uuid,
    inbox_consumer_id uuid,
    outbox_id uuid,
    message_id uuid NOT NULL,
    content_type character varying(256) COLLATE pg_catalog."default" NOT NULL,
    message_type text COLLATE pg_catalog."default" NOT NULL,
    body text COLLATE pg_catalog."default" NOT NULL,
    conversation_id uuid,
    correlation_id uuid,
    initiator_id uuid,
    request_id uuid,
    source_address character varying(256) COLLATE pg_catalog."default",
    destination_address character varying(256) COLLATE pg_catalog."default",
    response_address character varying(256) COLLATE pg_catalog."default",
    fault_address character varying(256) COLLATE pg_catalog."default",
    expiration_time timestamp with time zone,
    CONSTRAINT pk_outbox_message PRIMARY KEY (sequence_number)
);

CREATE TABLE IF NOT EXISTS public.outbox_state
(
    outbox_id uuid NOT NULL,
    lock_id uuid NOT NULL,
    row_version bytea,
    created timestamp with time zone NOT NULL,
    delivered timestamp with time zone,
    last_sequence_number bigint,
    CONSTRAINT pk_outbox_state PRIMARY KEY (outbox_id)
);

CREATE TABLE IF NOT EXISTS public.publishers
(
    id uuid NOT NULL DEFAULT uuidv7(),
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_publishers PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS public.book_authors
    ADD CONSTRAINT fk_book_authors_authors_author_id FOREIGN KEY (author_id)
    REFERENCES public.authors (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE RESTRICT;
CREATE INDEX IF NOT EXISTS ix_book_authors_author_id
    ON public.book_authors(author_id);


ALTER TABLE IF EXISTS public.book_authors
    ADD CONSTRAINT fk_book_authors_books_book_id FOREIGN KEY (book_id)
    REFERENCES public.books (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS ix_book_authors_book_id
    ON public.book_authors(book_id);


ALTER TABLE IF EXISTS public.books
    ADD CONSTRAINT fk_books_categories_category_id FOREIGN KEY (category_id)
    REFERENCES public.categories (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS ix_books_category_id
    ON public.books(category_id);


ALTER TABLE IF EXISTS public.books
    ADD CONSTRAINT fk_books_publishers_publisher_id FOREIGN KEY (publisher_id)
    REFERENCES public.publishers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS ix_books_publisher_id
    ON public.books(publisher_id);


ALTER TABLE IF EXISTS public.outbox_message
    ADD CONSTRAINT fk_outbox_message_inbox_state_inbox_message_id_inbox_consumer_ FOREIGN KEY (inbox_message_id, inbox_consumer_id)
    REFERENCES public.inbox_state (message_id, consumer_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.outbox_message
    ADD CONSTRAINT fk_outbox_message_outbox_state_outbox_id FOREIGN KEY (outbox_id)
    REFERENCES public.outbox_state (outbox_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;

END;

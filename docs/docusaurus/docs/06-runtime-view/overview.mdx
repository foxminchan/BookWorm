---
sidebar_position: 1
title: Overview
description: Runtime behavior and dynamic interactions of BookWorm services during key business scenarios and operations
keywords: [runtime view, service interactions, event-driven architecture, data flow, error handling, saga pattern]
last_update:
  author: Nhan Nguyen
---

# Runtime View Overview

The Runtime View describes the behavior of BookWorm's architecture during execution, focusing on the most important scenarios that demonstrate how the system components interact to fulfill business requirements.

## Purpose

This section illustrates how the static building blocks described in the [Building Block View](../05-building-block-view/overview.mdx) work together at runtime to deliver the BookWorm e-commerce functionality. Each scenario shows the dynamic aspects of the system, including:

- **Service Interactions**: How microservices communicate through events and commands
- **Data Flow**: How information flows through the system during key operations
- **Error Handling**: How the system handles failures and maintains consistency
- **Performance Characteristics**: Timing and scalability considerations

## Architecture Patterns in Action

BookWorm implements several key architectural patterns that are demonstrated across the runtime scenarios:

### Event-Driven Architecture

```mermaid
graph TB
    A[User Action] --> B[Command/Event]
    B --> C[Service Processing]
    C --> D[Domain Events]
    D --> E[Event Handlers]
    E --> F[Side Effects]
    F --> G[Notifications]
```

- **Asynchronous Communication**: Services communicate through domain events
- **Loose Coupling**: Services are decoupled through event-driven interactions
- **Scalability**: Event-driven design enables horizontal scaling
- **Resilience**: Event sourcing provides audit trails and replay capabilities

### Saga Pattern

BookWorm uses the **Choreography-based Saga** pattern for managing distributed transactions:

```mermaid
graph LR
    A[Service A] -->|Event| B[Service B]
    B -->|Event| C[Service C]
    C -->|Success/Failure| A
    A -->|Compensation| D[Rollback Actions]
```

- **Data Consistency**: Ensures eventual consistency across microservices
- **Compensation Logic**: Automatic rollback mechanisms for failed operations
- **Autonomous Services**: Each service manages its own state and compensations
- **Observable Workflows**: Complete audit trail of all saga steps

### CQRS (Command Query Responsibility Segregation)

```mermaid
graph TB
    subgraph Commands
        A[Create Order] --> B[Command Handler]
        B --> C[Domain Model]
        C --> D[Event Store]
    end

    subgraph Queries
        E[Order List] --> F[Query Handler]
        F --> G[Read Model]
    end

    D -->|Events| G
```

- **Separation of Concerns**: Commands and queries use different models
- **Performance Optimization**: Optimized read models for queries
- **Scalability**: Independent scaling of read and write operations

## Core Runtime Scenarios

BookWorm's runtime behavior is demonstrated through key business scenarios:

### 1. User Authentication Flow

**Scenario**: User signs into the BookWorm application
- **Trigger**: User initiates login process
- **Components**: Keycloak IAM, BookWorm Client, API Gateway
- **Pattern**: OAuth2 + PKCE authentication flow
- **Outcome**: Secure authenticated session with JWT tokens

[ðŸ‘‰ View Sign In Scenario](./signin-scenario.mdx)

### 2. Order Creation Flow

**Scenario**: User creates an order and processes checkout
- **Trigger**: User submits order for processing
- **Components**: Ordering, Finance, Basket, and Notification services
- **Pattern**: Choreography-based Saga with event sourcing
- **Outcome**: Order processed with proper basket cleanup and notifications

[ðŸ‘‰ View Create Order Scenario](./create-order-scenario.mdx)
